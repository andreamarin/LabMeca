
/tmp/build621887817022680454.tmp/determinante.cpp.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
   0:	d2 c0       	rjmp	.+420    	; 0x1a6 <__ctors_end>
   2:	00 00       	nop
   4:	fe c0       	rjmp	.+508    	; 0x202 <__bad_interrupt>
   6:	00 00       	nop
   8:	fc c0       	rjmp	.+504    	; 0x202 <__bad_interrupt>
   a:	00 00       	nop
   c:	fa c0       	rjmp	.+500    	; 0x202 <__bad_interrupt>
   e:	00 00       	nop
  10:	f8 c0       	rjmp	.+496    	; 0x202 <__bad_interrupt>
  12:	00 00       	nop
  14:	f6 c0       	rjmp	.+492    	; 0x202 <__bad_interrupt>
  16:	00 00       	nop
  18:	f4 c0       	rjmp	.+488    	; 0x202 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	f2 c0       	rjmp	.+484    	; 0x202 <__bad_interrupt>
  1e:	00 00       	nop
  20:	f0 c0       	rjmp	.+480    	; 0x202 <__bad_interrupt>
  22:	00 00       	nop
  24:	ee c0       	rjmp	.+476    	; 0x202 <__bad_interrupt>
  26:	00 00       	nop
  28:	ec c0       	rjmp	.+472    	; 0x202 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	ea c0       	rjmp	.+468    	; 0x202 <__bad_interrupt>
  2e:	00 00       	nop
  30:	e8 c0       	rjmp	.+464    	; 0x202 <__bad_interrupt>
  32:	00 00       	nop
  34:	e6 c0       	rjmp	.+460    	; 0x202 <__bad_interrupt>
  36:	00 00       	nop
  38:	e4 c0       	rjmp	.+456    	; 0x202 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	e2 c0       	rjmp	.+452    	; 0x202 <__bad_interrupt>
  3e:	00 00       	nop
  40:	e0 c0       	rjmp	.+448    	; 0x202 <__bad_interrupt>
  42:	00 00       	nop
  44:	de c0       	rjmp	.+444    	; 0x202 <__bad_interrupt>
  46:	00 00       	nop
  48:	dc c0       	rjmp	.+440    	; 0x202 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	da c0       	rjmp	.+436    	; 0x202 <__bad_interrupt>
  4e:	00 00       	nop
  50:	d8 c0       	rjmp	.+432    	; 0x202 <__bad_interrupt>
  52:	00 00       	nop
  54:	d6 c0       	rjmp	.+428    	; 0x202 <__bad_interrupt>
  56:	00 00       	nop
  58:	d4 c0       	rjmp	.+424    	; 0x202 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	11 c5       	rjmp	.+2594   	; 0xa80 <__vector_23>
  5e:	00 00       	nop
  60:	d0 c0       	rjmp	.+416    	; 0x202 <__bad_interrupt>
  62:	00 00       	nop
  64:	d5 c1       	rjmp	.+938    	; 0x410 <__vector_25>
  66:	00 00       	nop
  68:	b7 c2       	rjmp	.+1390   	; 0x5d8 <__vector_26>
  6a:	00 00       	nop
  6c:	ca c0       	rjmp	.+404    	; 0x202 <__bad_interrupt>
  6e:	00 00       	nop
  70:	c8 c0       	rjmp	.+400    	; 0x202 <__bad_interrupt>
  72:	00 00       	nop
  74:	c6 c0       	rjmp	.+396    	; 0x202 <__bad_interrupt>
  76:	00 00       	nop
  78:	c4 c0       	rjmp	.+392    	; 0x202 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	c2 c0       	rjmp	.+388    	; 0x202 <__bad_interrupt>
  7e:	00 00       	nop
  80:	c0 c0       	rjmp	.+384    	; 0x202 <__bad_interrupt>
  82:	00 00       	nop
  84:	be c0       	rjmp	.+380    	; 0x202 <__bad_interrupt>
  86:	00 00       	nop
  88:	bc c0       	rjmp	.+376    	; 0x202 <__bad_interrupt>
  8a:	00 00       	nop
  8c:	ba c0       	rjmp	.+372    	; 0x202 <__bad_interrupt>
  8e:	00 00       	nop
  90:	f2 c1       	rjmp	.+996    	; 0x476 <__vector_36>
  92:	00 00       	nop
  94:	e0 c2       	rjmp	.+1472   	; 0x656 <__vector_37>
  96:	00 00       	nop
  98:	b4 c0       	rjmp	.+360    	; 0x202 <__bad_interrupt>
  9a:	00 00       	nop
  9c:	b2 c0       	rjmp	.+356    	; 0x202 <__bad_interrupt>
  9e:	00 00       	nop
  a0:	b0 c0       	rjmp	.+352    	; 0x202 <__bad_interrupt>
  a2:	00 00       	nop
  a4:	ae c0       	rjmp	.+348    	; 0x202 <__bad_interrupt>
  a6:	00 00       	nop
  a8:	ac c0       	rjmp	.+344    	; 0x202 <__bad_interrupt>
  aa:	00 00       	nop
  ac:	aa c0       	rjmp	.+340    	; 0x202 <__bad_interrupt>
  ae:	00 00       	nop
  b0:	a8 c0       	rjmp	.+336    	; 0x202 <__bad_interrupt>
  b2:	00 00       	nop
  b4:	a6 c0       	rjmp	.+332    	; 0x202 <__bad_interrupt>
  b6:	00 00       	nop
  b8:	a4 c0       	rjmp	.+328    	; 0x202 <__bad_interrupt>
  ba:	00 00       	nop
  bc:	a2 c0       	rjmp	.+324    	; 0x202 <__bad_interrupt>
  be:	00 00       	nop
  c0:	a0 c0       	rjmp	.+320    	; 0x202 <__bad_interrupt>
  c2:	00 00       	nop
  c4:	9e c0       	rjmp	.+316    	; 0x202 <__bad_interrupt>
  c6:	00 00       	nop
  c8:	9c c0       	rjmp	.+312    	; 0x202 <__bad_interrupt>
  ca:	00 00       	nop
  cc:	07 c2       	rjmp	.+1038   	; 0x4dc <__vector_51>
  ce:	00 00       	nop
  d0:	01 c3       	rjmp	.+1538   	; 0x6d4 <__vector_52>
  d2:	00 00       	nop
  d4:	96 c0       	rjmp	.+300    	; 0x202 <__bad_interrupt>
  d6:	00 00       	nop
  d8:	34 c2       	rjmp	.+1128   	; 0x542 <__vector_54>
  da:	00 00       	nop
  dc:	3a c3       	rjmp	.+1652   	; 0x752 <__vector_55>
  de:	00 00       	nop
  e0:	90 c0       	rjmp	.+288    	; 0x202 <__bad_interrupt>
	...

000000e4 <__trampolines_end>:
  e4:	01 02       	muls	r16, r17
  e6:	10 20       	and	r1, r0
  e8:	20 08       	sbc	r2, r0
  ea:	08 10       	cpse	r0, r8
  ec:	20 40       	sbci	r18, 0x00	; 0
  ee:	10 20       	and	r1, r0
  f0:	40 80       	ld	r4, Z
  f2:	02 01       	movw	r0, r4
  f4:	02 01       	movw	r0, r4
  f6:	08 04       	cpc	r0, r8
  f8:	02 01       	movw	r0, r4
  fa:	01 02       	muls	r16, r17
  fc:	04 08       	sbc	r0, r4
  fe:	10 20       	and	r1, r0
 100:	40 80       	ld	r4, Z
 102:	80 40       	sbci	r24, 0x00	; 0
 104:	20 10       	cpse	r2, r0
 106:	08 04       	cpc	r0, r8
 108:	02 01       	movw	r0, r4
 10a:	80 04       	cpc	r8, r0
 10c:	02 01       	movw	r0, r4
 10e:	80 40       	sbci	r24, 0x00	; 0
 110:	20 10       	cpse	r2, r0
 112:	08 04       	cpc	r0, r8
 114:	02 01       	movw	r0, r4
 116:	08 04       	cpc	r0, r8
 118:	02 01       	movw	r0, r4
 11a:	01 02       	muls	r16, r17
 11c:	04 08       	sbc	r0, r4
 11e:	10 20       	and	r1, r0
 120:	40 80       	ld	r4, Z
 122:	01 02       	muls	r16, r17
 124:	04 08       	sbc	r0, r4
 126:	10 20       	and	r1, r0
 128:	40 80       	ld	r4, Z

0000012a <digital_pin_to_port_PGM>:
 12a:	05 05 05 05 07 05 08 08 08 08 02 02 02 02 0a 0a     ................
 13a:	08 08 04 04 04 04 01 01 01 01 01 01 01 01 03 03     ................
 14a:	03 03 03 03 03 03 04 07 07 07 0c 0c 0c 0c 0c 0c     ................
 15a:	0c 0c 02 02 02 02 06 06 06 06 06 06 06 06 0b 0b     ................
 16a:	0b 0b 0b 0b 0b 0b                                   ......

00000170 <port_to_output_PGM>:
 170:	00 00 22 00 25 00 28 00 2b 00 2e 00 31 00 34 00     ..".%.(.+...1.4.
 180:	02 01 00 00 05 01 08 01 0b 01                       ..........

0000018a <port_to_mode_PGM>:
 18a:	00 00 21 00 24 00 27 00 2a 00 2d 00 30 00 33 00     ..!.$.'.*.-.0.3.
 19a:	01 01 00 00 04 01 07 01 0a 01                       ..........

000001a4 <__ctors_start>:
 1a4:	6e 04       	cpc	r6, r14

000001a6 <__ctors_end>:
 1a6:	11 24       	eor	r1, r1
 1a8:	1f be       	out	0x3f, r1	; 63
 1aa:	cf ef       	ldi	r28, 0xFF	; 255
 1ac:	d1 e2       	ldi	r29, 0x21	; 33
 1ae:	de bf       	out	0x3e, r29	; 62
 1b0:	cd bf       	out	0x3d, r28	; 61
 1b2:	00 e0       	ldi	r16, 0x00	; 0
 1b4:	0c bf       	out	0x3c, r16	; 60

000001b6 <__do_copy_data>:
 1b6:	12 e0       	ldi	r17, 0x02	; 2
 1b8:	a0 e0       	ldi	r26, 0x00	; 0
 1ba:	b2 e0       	ldi	r27, 0x02	; 2
 1bc:	e0 e8       	ldi	r30, 0x80	; 128
 1be:	fc e0       	ldi	r31, 0x0C	; 12
 1c0:	00 e0       	ldi	r16, 0x00	; 0
 1c2:	0b bf       	out	0x3b, r16	; 59
 1c4:	02 c0       	rjmp	.+4      	; 0x1ca <__do_copy_data+0x14>
 1c6:	07 90       	elpm	r0, Z+
 1c8:	0d 92       	st	X+, r0
 1ca:	a2 31       	cpi	r26, 0x12	; 18
 1cc:	b1 07       	cpc	r27, r17
 1ce:	d9 f7       	brne	.-10     	; 0x1c6 <__do_copy_data+0x10>

000001d0 <__do_clear_bss>:
 1d0:	24 e0       	ldi	r18, 0x04	; 4
 1d2:	a2 e1       	ldi	r26, 0x12	; 18
 1d4:	b2 e0       	ldi	r27, 0x02	; 2
 1d6:	01 c0       	rjmp	.+2      	; 0x1da <.do_clear_bss_start>

000001d8 <.do_clear_bss_loop>:
 1d8:	1d 92       	st	X+, r1

000001da <.do_clear_bss_start>:
 1da:	a3 3c       	cpi	r26, 0xC3	; 195
 1dc:	b2 07       	cpc	r27, r18
 1de:	e1 f7       	brne	.-8      	; 0x1d8 <.do_clear_bss_loop>

000001e0 <__do_global_ctors>:
 1e0:	10 e0       	ldi	r17, 0x00	; 0
 1e2:	c3 ed       	ldi	r28, 0xD3	; 211
 1e4:	d0 e0       	ldi	r29, 0x00	; 0
 1e6:	00 e0       	ldi	r16, 0x00	; 0
 1e8:	05 c0       	rjmp	.+10     	; 0x1f4 <__do_global_ctors+0x14>
 1ea:	21 97       	sbiw	r28, 0x01	; 1
 1ec:	01 09       	sbc	r16, r1
 1ee:	80 2f       	mov	r24, r16
 1f0:	fe 01       	movw	r30, r28
 1f2:	3c d5       	rcall	.+2680   	; 0xc6c <__tablejump2__>
 1f4:	c2 3d       	cpi	r28, 0xD2	; 210
 1f6:	d1 07       	cpc	r29, r17
 1f8:	80 e0       	ldi	r24, 0x00	; 0
 1fa:	08 07       	cpc	r16, r24
 1fc:	b1 f7       	brne	.-20     	; 0x1ea <__do_global_ctors+0xa>
 1fe:	4b d0       	rcall	.+150    	; 0x296 <main>
 200:	3d c5       	rjmp	.+2682   	; 0xc7c <_exit>

00000202 <__bad_interrupt>:
 202:	fe ce       	rjmp	.-516    	; 0x0 <__vectors>

00000204 <setup>:
 204:	61 e0       	ldi	r22, 0x01	; 1
 206:	80 91 00 02 	lds	r24, 0x0200
 20a:	09 d0       	rcall	.+18     	; 0x21e <pinMode>
 20c:	40 e8       	ldi	r20, 0x80	; 128
 20e:	55 e2       	ldi	r21, 0x25	; 37
 210:	60 e0       	ldi	r22, 0x00	; 0
 212:	70 e0       	ldi	r23, 0x00	; 0
 214:	88 e7       	ldi	r24, 0x78	; 120
 216:	92 e0       	ldi	r25, 0x02	; 2
 218:	db c2       	rjmp	.+1462   	; 0x7d0 <_ZN14HardwareSerial5beginEm>

0000021a <loop>:
 21a:	02 e4       	ldi	r16, 0x42	; 66
 21c:	08 95       	ret

0000021e <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
 21e:	cf 93       	push	r28
 220:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
 222:	90 e0       	ldi	r25, 0x00	; 0
 224:	fc 01       	movw	r30, r24
 226:	ec 51       	subi	r30, 0x1C	; 28
 228:	ff 4f       	sbci	r31, 0xFF	; 255
 22a:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
 22c:	fc 01       	movw	r30, r24
 22e:	e6 5d       	subi	r30, 0xD6	; 214
 230:	fe 4f       	sbci	r31, 0xFE	; 254
 232:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
 234:	88 23       	and	r24, r24
 236:	61 f1       	breq	.+88     	; 0x290 <pinMode+0x72>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
 238:	90 e0       	ldi	r25, 0x00	; 0
 23a:	88 0f       	add	r24, r24
 23c:	99 1f       	adc	r25, r25
 23e:	fc 01       	movw	r30, r24
 240:	e6 57       	subi	r30, 0x76	; 118
 242:	fe 4f       	sbci	r31, 0xFE	; 254
 244:	c5 91       	lpm	r28, Z+
 246:	d4 91       	lpm	r29, Z
	out = portOutputRegister(port);
 248:	fc 01       	movw	r30, r24
 24a:	e0 59       	subi	r30, 0x90	; 144
 24c:	fe 4f       	sbci	r31, 0xFE	; 254
 24e:	a5 91       	lpm	r26, Z+
 250:	b4 91       	lpm	r27, Z

	if (mode == INPUT) { 
 252:	61 11       	cpse	r22, r1
 254:	09 c0       	rjmp	.+18     	; 0x268 <pinMode+0x4a>
		uint8_t oldSREG = SREG;
 256:	9f b7       	in	r25, 0x3f	; 63
                cli();
 258:	f8 94       	cli
		*reg &= ~bit;
 25a:	88 81       	ld	r24, Y
 25c:	20 95       	com	r18
 25e:	82 23       	and	r24, r18
 260:	88 83       	st	Y, r24
		*out &= ~bit;
 262:	ec 91       	ld	r30, X
 264:	2e 23       	and	r18, r30
 266:	0b c0       	rjmp	.+22     	; 0x27e <pinMode+0x60>
		SREG = oldSREG;
	} else if (mode == INPUT_PULLUP) {
 268:	62 30       	cpi	r22, 0x02	; 2
 26a:	61 f4       	brne	.+24     	; 0x284 <pinMode+0x66>
		uint8_t oldSREG = SREG;
 26c:	9f b7       	in	r25, 0x3f	; 63
                cli();
 26e:	f8 94       	cli
		*reg &= ~bit;
 270:	38 81       	ld	r19, Y
 272:	82 2f       	mov	r24, r18
 274:	80 95       	com	r24
 276:	83 23       	and	r24, r19
 278:	88 83       	st	Y, r24
		*out |= bit;
 27a:	ec 91       	ld	r30, X
 27c:	2e 2b       	or	r18, r30
 27e:	2c 93       	st	X, r18
		SREG = oldSREG;
 280:	9f bf       	out	0x3f, r25	; 63
 282:	06 c0       	rjmp	.+12     	; 0x290 <pinMode+0x72>
	} else {
		uint8_t oldSREG = SREG;
 284:	8f b7       	in	r24, 0x3f	; 63
                cli();
 286:	f8 94       	cli
		*reg |= bit;
 288:	e8 81       	ld	r30, Y
 28a:	2e 2b       	or	r18, r30
 28c:	28 83       	st	Y, r18
		SREG = oldSREG;
 28e:	8f bf       	out	0x3f, r24	; 63
	}
}
 290:	df 91       	pop	r29
 292:	cf 91       	pop	r28
 294:	08 95       	ret

00000296 <main>:
#include <Arduino.h>

int main(void)
{
	init();
 296:	3e d4       	rcall	.+2172   	; 0xb14 <init>
 298:	b5 df       	rcall	.-150    	; 0x204 <setup>

#if defined(USBCON)
	USBDevice.attach();
#endif
	
	setup();
 29a:	c3 ed       	ldi	r28, 0xD3	; 211
 29c:	d2 e0       	ldi	r29, 0x02	; 2
    
	for (;;) {
		loop();
		if (serialEventRun) serialEventRun();
 29e:	bd df       	rcall	.-134    	; 0x21a <loop>
 2a0:	20 97       	sbiw	r28, 0x00	; 0
#endif
	
	setup();
    
	for (;;) {
		loop();
 2a2:	e9 f3       	breq	.-6      	; 0x29e <main+0x8>
 2a4:	80 d1       	rcall	.+768    	; 0x5a6 <_Z14serialEventRunv>
		if (serialEventRun) serialEventRun();
 2a6:	fb cf       	rjmp	.-10     	; 0x29e <main+0x8>

000002a8 <_ZN14HardwareSerial9availableEv>:
  _rx_buffer->head = _rx_buffer->tail;
}

int HardwareSerial::available(void)
{
  return (unsigned int)(SERIAL_BUFFER_SIZE + _rx_buffer->head - _rx_buffer->tail) % SERIAL_BUFFER_SIZE;
 2a8:	fc 01       	movw	r30, r24
 2aa:	24 85       	ldd	r18, Z+12	; 0x0c
 2ac:	35 85       	ldd	r19, Z+13	; 0x0d
 2ae:	f9 01       	movw	r30, r18
 2b0:	e0 5c       	subi	r30, 0xC0	; 192
 2b2:	ff 4f       	sbci	r31, 0xFF	; 255
 2b4:	80 81       	ld	r24, Z
 2b6:	91 81       	ldd	r25, Z+1	; 0x01
 2b8:	32 96       	adiw	r30, 0x02	; 2
 2ba:	20 81       	ld	r18, Z
 2bc:	31 81       	ldd	r19, Z+1	; 0x01
 2be:	82 1b       	sub	r24, r18
 2c0:	93 0b       	sbc	r25, r19
}
 2c2:	8f 73       	andi	r24, 0x3F	; 63
 2c4:	99 27       	eor	r25, r25
 2c6:	08 95       	ret

000002c8 <_ZN14HardwareSerial4peekEv>:

int HardwareSerial::peek(void)
{
  if (_rx_buffer->head == _rx_buffer->tail) {
 2c8:	dc 01       	movw	r26, r24
 2ca:	1c 96       	adiw	r26, 0x0c	; 12
 2cc:	ed 91       	ld	r30, X+
 2ce:	fc 91       	ld	r31, X
 2d0:	1d 97       	sbiw	r26, 0x0d	; 13
 2d2:	df 01       	movw	r26, r30
 2d4:	a0 5c       	subi	r26, 0xC0	; 192
 2d6:	bf 4f       	sbci	r27, 0xFF	; 255
 2d8:	2d 91       	ld	r18, X+
 2da:	3c 91       	ld	r19, X
 2dc:	11 97       	sbiw	r26, 0x01	; 1
 2de:	12 96       	adiw	r26, 0x02	; 2
 2e0:	8d 91       	ld	r24, X+
 2e2:	9c 91       	ld	r25, X
 2e4:	11 97       	sbiw	r26, 0x01	; 1
 2e6:	28 17       	cp	r18, r24
 2e8:	39 07       	cpc	r19, r25
 2ea:	39 f0       	breq	.+14     	; 0x2fa <_ZN14HardwareSerial4peekEv+0x32>
    return -1;
  } else {
    return _rx_buffer->buffer[_rx_buffer->tail];
 2ec:	8d 91       	ld	r24, X+
 2ee:	9c 91       	ld	r25, X
 2f0:	e8 0f       	add	r30, r24
 2f2:	f9 1f       	adc	r31, r25
 2f4:	80 81       	ld	r24, Z
 2f6:	90 e0       	ldi	r25, 0x00	; 0
 2f8:	08 95       	ret
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer->head == _rx_buffer->tail) {
    return -1;
 2fa:	8f ef       	ldi	r24, 0xFF	; 255
 2fc:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    return _rx_buffer->buffer[_rx_buffer->tail];
  }
}
 2fe:	08 95       	ret

00000300 <_ZN14HardwareSerial4readEv>:

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer->head == _rx_buffer->tail) {
 300:	fc 01       	movw	r30, r24
 302:	a4 85       	ldd	r26, Z+12	; 0x0c
 304:	b5 85       	ldd	r27, Z+13	; 0x0d
 306:	fd 01       	movw	r30, r26
 308:	e0 5c       	subi	r30, 0xC0	; 192
 30a:	ff 4f       	sbci	r31, 0xFF	; 255
 30c:	20 81       	ld	r18, Z
 30e:	31 81       	ldd	r19, Z+1	; 0x01
 310:	32 96       	adiw	r30, 0x02	; 2
 312:	80 81       	ld	r24, Z
 314:	91 81       	ldd	r25, Z+1	; 0x01
 316:	28 17       	cp	r18, r24
 318:	39 07       	cpc	r19, r25
 31a:	79 f0       	breq	.+30     	; 0x33a <_ZN14HardwareSerial4readEv+0x3a>
    return -1;
  } else {
    unsigned char c = _rx_buffer->buffer[_rx_buffer->tail];
 31c:	80 81       	ld	r24, Z
 31e:	91 81       	ldd	r25, Z+1	; 0x01
 320:	a8 0f       	add	r26, r24
 322:	b9 1f       	adc	r27, r25
 324:	8c 91       	ld	r24, X
    _rx_buffer->tail = (unsigned int)(_rx_buffer->tail + 1) % SERIAL_BUFFER_SIZE;
 326:	20 81       	ld	r18, Z
 328:	31 81       	ldd	r19, Z+1	; 0x01
 32a:	2f 5f       	subi	r18, 0xFF	; 255
 32c:	3f 4f       	sbci	r19, 0xFF	; 255
 32e:	2f 73       	andi	r18, 0x3F	; 63
 330:	33 27       	eor	r19, r19
 332:	31 83       	std	Z+1, r19	; 0x01
 334:	20 83       	st	Z, r18
    return c;
 336:	90 e0       	ldi	r25, 0x00	; 0
 338:	08 95       	ret

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer->head == _rx_buffer->tail) {
    return -1;
 33a:	8f ef       	ldi	r24, 0xFF	; 255
 33c:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    unsigned char c = _rx_buffer->buffer[_rx_buffer->tail];
    _rx_buffer->tail = (unsigned int)(_rx_buffer->tail + 1) % SERIAL_BUFFER_SIZE;
    return c;
  }
}
 33e:	08 95       	ret

00000340 <_ZN14HardwareSerial5flushEv>:

void HardwareSerial::flush()
{
 340:	fc 01       	movw	r30, r24
  // UDR is kept full while the buffer is not empty, so TXC triggers when EMPTY && SENT
  while (transmitting && ! (*_ucsra & _BV(TXC0)));
 342:	81 a1       	ldd	r24, Z+33	; 0x21
 344:	88 23       	and	r24, r24
 346:	29 f0       	breq	.+10     	; 0x352 <_ZN14HardwareSerial5flushEv+0x12>
 348:	a4 89       	ldd	r26, Z+20	; 0x14
 34a:	b5 89       	ldd	r27, Z+21	; 0x15
 34c:	8c 91       	ld	r24, X
 34e:	86 ff       	sbrs	r24, 6
 350:	fb cf       	rjmp	.-10     	; 0x348 <_ZN14HardwareSerial5flushEv+0x8>
  transmitting = false;
 352:	11 a2       	std	Z+33, r1	; 0x21
 354:	08 95       	ret

00000356 <_ZN14HardwareSerial5writeEh>:
}

size_t HardwareSerial::write(uint8_t c)
{
 356:	0f 93       	push	r16
 358:	1f 93       	push	r17
 35a:	cf 93       	push	r28
 35c:	df 93       	push	r29
 35e:	fc 01       	movw	r30, r24
  int i = (_tx_buffer->head + 1) % SERIAL_BUFFER_SIZE;
 360:	a6 85       	ldd	r26, Z+14	; 0x0e
 362:	b7 85       	ldd	r27, Z+15	; 0x0f
 364:	8d 01       	movw	r16, r26
 366:	00 5c       	subi	r16, 0xC0	; 192
 368:	1f 4f       	sbci	r17, 0xFF	; 255
 36a:	e8 01       	movw	r28, r16
 36c:	88 81       	ld	r24, Y
 36e:	99 81       	ldd	r25, Y+1	; 0x01
 370:	01 96       	adiw	r24, 0x01	; 1
 372:	8f 73       	andi	r24, 0x3F	; 63
 374:	99 27       	eor	r25, r25
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  // ???: return 0 here instead?
  while (i == _tx_buffer->tail)
 376:	ad 01       	movw	r20, r26
 378:	4e 5b       	subi	r20, 0xBE	; 190
 37a:	5f 4f       	sbci	r21, 0xFF	; 255
 37c:	ea 01       	movw	r28, r20
 37e:	28 81       	ld	r18, Y
 380:	39 81       	ldd	r19, Y+1	; 0x01
 382:	82 17       	cp	r24, r18
 384:	93 07       	cpc	r25, r19
 386:	d1 f3       	breq	.-12     	; 0x37c <_ZN14HardwareSerial5writeEh+0x26>
    ;
	
  _tx_buffer->buffer[_tx_buffer->head] = c;
 388:	e8 01       	movw	r28, r16
 38a:	28 81       	ld	r18, Y
 38c:	39 81       	ldd	r19, Y+1	; 0x01
 38e:	a2 0f       	add	r26, r18
 390:	b3 1f       	adc	r27, r19
 392:	6c 93       	st	X, r22
  _tx_buffer->head = i;
 394:	a6 85       	ldd	r26, Z+14	; 0x0e
 396:	b7 85       	ldd	r27, Z+15	; 0x0f
 398:	a0 5c       	subi	r26, 0xC0	; 192
 39a:	bf 4f       	sbci	r27, 0xFF	; 255
 39c:	11 96       	adiw	r26, 0x01	; 1
 39e:	9c 93       	st	X, r25
 3a0:	8e 93       	st	-X, r24
	
  sbi(*_ucsrb, _udrie);
 3a2:	a6 89       	ldd	r26, Z+22	; 0x16
 3a4:	b7 89       	ldd	r27, Z+23	; 0x17
 3a6:	2c 91       	ld	r18, X
 3a8:	81 e0       	ldi	r24, 0x01	; 1
 3aa:	90 e0       	ldi	r25, 0x00	; 0
 3ac:	07 8c       	ldd	r0, Z+31	; 0x1f
 3ae:	02 c0       	rjmp	.+4      	; 0x3b4 <_ZN14HardwareSerial5writeEh+0x5e>
 3b0:	88 0f       	add	r24, r24
 3b2:	99 1f       	adc	r25, r25
 3b4:	0a 94       	dec	r0
 3b6:	e2 f7       	brpl	.-8      	; 0x3b0 <_ZN14HardwareSerial5writeEh+0x5a>
 3b8:	82 2b       	or	r24, r18
 3ba:	8c 93       	st	X, r24
  // clear the TXC bit -- "can be cleared by writing a one to its bit location"
  transmitting = true;
 3bc:	81 e0       	ldi	r24, 0x01	; 1
 3be:	81 a3       	std	Z+33, r24	; 0x21
  sbi(*_ucsra, TXC0);
 3c0:	04 88       	ldd	r0, Z+20	; 0x14
 3c2:	f5 89       	ldd	r31, Z+21	; 0x15
 3c4:	e0 2d       	mov	r30, r0
 3c6:	80 81       	ld	r24, Z
 3c8:	80 64       	ori	r24, 0x40	; 64
 3ca:	80 83       	st	Z, r24
  
  return 1;
}
 3cc:	81 e0       	ldi	r24, 0x01	; 1
 3ce:	90 e0       	ldi	r25, 0x00	; 0
 3d0:	df 91       	pop	r29
 3d2:	cf 91       	pop	r28
 3d4:	1f 91       	pop	r17
 3d6:	0f 91       	pop	r16
 3d8:	08 95       	ret

000003da <_Z10store_charhP11ring_buffer>:
  ring_buffer tx_buffer3  =  { { 0 }, 0, 0 };
#endif

inline void store_char(unsigned char c, ring_buffer *buffer)
{
  int i = (unsigned int)(buffer->head + 1) % SERIAL_BUFFER_SIZE;
 3da:	fb 01       	movw	r30, r22
 3dc:	e0 5c       	subi	r30, 0xC0	; 192
 3de:	ff 4f       	sbci	r31, 0xFF	; 255
 3e0:	20 81       	ld	r18, Z
 3e2:	31 81       	ldd	r19, Z+1	; 0x01
 3e4:	2f 5f       	subi	r18, 0xFF	; 255
 3e6:	3f 4f       	sbci	r19, 0xFF	; 255
 3e8:	2f 73       	andi	r18, 0x3F	; 63
 3ea:	33 27       	eor	r19, r19

  // if we should be storing the received character into the location
  // just before the tail (meaning that the head would advance to the
  // current location of the tail), we're about to overflow the buffer
  // and so we don't write the character or advance the head.
  if (i != buffer->tail) {
 3ec:	db 01       	movw	r26, r22
 3ee:	ae 5b       	subi	r26, 0xBE	; 190
 3f0:	bf 4f       	sbci	r27, 0xFF	; 255
 3f2:	4d 91       	ld	r20, X+
 3f4:	5c 91       	ld	r21, X
 3f6:	24 17       	cp	r18, r20
 3f8:	35 07       	cpc	r19, r21
 3fa:	41 f0       	breq	.+16     	; 0x40c <_Z10store_charhP11ring_buffer+0x32>
    buffer->buffer[buffer->head] = c;
 3fc:	40 81       	ld	r20, Z
 3fe:	51 81       	ldd	r21, Z+1	; 0x01
 400:	db 01       	movw	r26, r22
 402:	a4 0f       	add	r26, r20
 404:	b5 1f       	adc	r27, r21
 406:	8c 93       	st	X, r24
    buffer->head = i;
 408:	31 83       	std	Z+1, r19	; 0x01
 40a:	20 83       	st	Z, r18
 40c:	08 95       	ret

0000040e <_Z11serialEventv>:
#if !defined(USART_RX_vect) && !defined(USART0_RX_vect) && \
    !defined(USART_RXC_vect)
  #error "Don't know what the Data Received vector is called for the first UART"
#else
  void serialEvent() __attribute__((weak));
  void serialEvent() {}
 40e:	08 95       	ret

00000410 <__vector_25>:
#elif defined(USART0_RX_vect)
  ISR(USART0_RX_vect)
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#endif
  {
 410:	1f 92       	push	r1
 412:	0f 92       	push	r0
 414:	0f b6       	in	r0, 0x3f	; 63
 416:	0f 92       	push	r0
 418:	11 24       	eor	r1, r1
 41a:	0b b6       	in	r0, 0x3b	; 59
 41c:	0f 92       	push	r0
 41e:	2f 93       	push	r18
 420:	3f 93       	push	r19
 422:	4f 93       	push	r20
 424:	5f 93       	push	r21
 426:	6f 93       	push	r22
 428:	7f 93       	push	r23
 42a:	8f 93       	push	r24
 42c:	9f 93       	push	r25
 42e:	af 93       	push	r26
 430:	bf 93       	push	r27
 432:	ef 93       	push	r30
 434:	ff 93       	push	r31
  #if defined(UDR0)
    if (bit_is_clear(UCSR0A, UPE0)) {
 436:	80 91 c0 00 	lds	r24, 0x00C0
 43a:	82 fd       	sbrc	r24, 2
 43c:	06 c0       	rjmp	.+12     	; 0x44a <__vector_25+0x3a>
      unsigned char c = UDR0;
 43e:	80 91 c6 00 	lds	r24, 0x00C6
      store_char(c, &rx_buffer);
 442:	66 e7       	ldi	r22, 0x76	; 118
 444:	74 e0       	ldi	r23, 0x04	; 4
 446:	c9 df       	rcall	.-110    	; 0x3da <_Z10store_charhP11ring_buffer>
 448:	02 c0       	rjmp	.+4      	; 0x44e <__vector_25+0x3e>
 44a:	80 91 c6 00 	lds	r24, 0x00C6
    } else {
      unsigned char c = UDR0;
 44e:	ff 91       	pop	r31
      unsigned char c = UDR;
    };
  #else
    #error UDR not defined
  #endif
  }
 450:	ef 91       	pop	r30
 452:	bf 91       	pop	r27
 454:	af 91       	pop	r26
 456:	9f 91       	pop	r25
 458:	8f 91       	pop	r24
 45a:	7f 91       	pop	r23
 45c:	6f 91       	pop	r22
 45e:	5f 91       	pop	r21
 460:	4f 91       	pop	r20
 462:	3f 91       	pop	r19
 464:	2f 91       	pop	r18
 466:	0f 90       	pop	r0
 468:	0b be       	out	0x3b, r0	; 59
 46a:	0f 90       	pop	r0
 46c:	0f be       	out	0x3f, r0	; 63
 46e:	0f 90       	pop	r0
 470:	1f 90       	pop	r1
 472:	18 95       	reti

00000474 <_Z12serialEvent1v>:
#endif
#endif

#if defined(USART1_RX_vect)
  void serialEvent1() __attribute__((weak));
  void serialEvent1() {}
 474:	08 95       	ret

00000476 <__vector_36>:
  #define serialEvent1_implemented
  ISR(USART1_RX_vect)
  {
 476:	1f 92       	push	r1
 478:	0f 92       	push	r0
 47a:	0f b6       	in	r0, 0x3f	; 63
 47c:	0f 92       	push	r0
 47e:	11 24       	eor	r1, r1
 480:	0b b6       	in	r0, 0x3b	; 59
 482:	0f 92       	push	r0
 484:	2f 93       	push	r18
 486:	3f 93       	push	r19
 488:	4f 93       	push	r20
 48a:	5f 93       	push	r21
 48c:	6f 93       	push	r22
 48e:	7f 93       	push	r23
 490:	8f 93       	push	r24
 492:	9f 93       	push	r25
 494:	af 93       	push	r26
 496:	bf 93       	push	r27
 498:	ef 93       	push	r30
 49a:	ff 93       	push	r31
    if (bit_is_clear(UCSR1A, UPE1)) {
 49c:	80 91 c8 00 	lds	r24, 0x00C8
 4a0:	82 fd       	sbrc	r24, 2
 4a2:	06 c0       	rjmp	.+12     	; 0x4b0 <__vector_36+0x3a>
      unsigned char c = UDR1;
 4a4:	80 91 ce 00 	lds	r24, 0x00CE
      store_char(c, &rx_buffer1);
 4a8:	6e ee       	ldi	r22, 0xEE	; 238
 4aa:	73 e0       	ldi	r23, 0x03	; 3
 4ac:	96 df       	rcall	.-212    	; 0x3da <_Z10store_charhP11ring_buffer>
 4ae:	02 c0       	rjmp	.+4      	; 0x4b4 <__vector_36+0x3e>
 4b0:	80 91 ce 00 	lds	r24, 0x00CE
    } else {
      unsigned char c = UDR1;
 4b4:	ff 91       	pop	r31
    };
  }
 4b6:	ef 91       	pop	r30
 4b8:	bf 91       	pop	r27
 4ba:	af 91       	pop	r26
 4bc:	9f 91       	pop	r25
 4be:	8f 91       	pop	r24
 4c0:	7f 91       	pop	r23
 4c2:	6f 91       	pop	r22
 4c4:	5f 91       	pop	r21
 4c6:	4f 91       	pop	r20
 4c8:	3f 91       	pop	r19
 4ca:	2f 91       	pop	r18
 4cc:	0f 90       	pop	r0
 4ce:	0b be       	out	0x3b, r0	; 59
 4d0:	0f 90       	pop	r0
 4d2:	0f be       	out	0x3f, r0	; 63
 4d4:	0f 90       	pop	r0
 4d6:	1f 90       	pop	r1
 4d8:	18 95       	reti

000004da <_Z12serialEvent2v>:
#endif

#if defined(USART2_RX_vect) && defined(UDR2)
  void serialEvent2() __attribute__((weak));
  void serialEvent2() {}
 4da:	08 95       	ret

000004dc <__vector_51>:
  #define serialEvent2_implemented
  ISR(USART2_RX_vect)
  {
 4dc:	1f 92       	push	r1
 4de:	0f 92       	push	r0
 4e0:	0f b6       	in	r0, 0x3f	; 63
 4e2:	0f 92       	push	r0
 4e4:	11 24       	eor	r1, r1
 4e6:	0b b6       	in	r0, 0x3b	; 59
 4e8:	0f 92       	push	r0
 4ea:	2f 93       	push	r18
 4ec:	3f 93       	push	r19
 4ee:	4f 93       	push	r20
 4f0:	5f 93       	push	r21
 4f2:	6f 93       	push	r22
 4f4:	7f 93       	push	r23
 4f6:	8f 93       	push	r24
 4f8:	9f 93       	push	r25
 4fa:	af 93       	push	r26
 4fc:	bf 93       	push	r27
 4fe:	ef 93       	push	r30
 500:	ff 93       	push	r31
    if (bit_is_clear(UCSR2A, UPE2)) {
 502:	80 91 d0 00 	lds	r24, 0x00D0
 506:	82 fd       	sbrc	r24, 2
 508:	06 c0       	rjmp	.+12     	; 0x516 <__vector_51+0x3a>
      unsigned char c = UDR2;
 50a:	80 91 d6 00 	lds	r24, 0x00D6
      store_char(c, &rx_buffer2);
 50e:	66 e6       	ldi	r22, 0x66	; 102
 510:	73 e0       	ldi	r23, 0x03	; 3
 512:	63 df       	rcall	.-314    	; 0x3da <_Z10store_charhP11ring_buffer>
 514:	02 c0       	rjmp	.+4      	; 0x51a <__vector_51+0x3e>
 516:	80 91 d6 00 	lds	r24, 0x00D6
    } else {
      unsigned char c = UDR2;
 51a:	ff 91       	pop	r31
    };
  }
 51c:	ef 91       	pop	r30
 51e:	bf 91       	pop	r27
 520:	af 91       	pop	r26
 522:	9f 91       	pop	r25
 524:	8f 91       	pop	r24
 526:	7f 91       	pop	r23
 528:	6f 91       	pop	r22
 52a:	5f 91       	pop	r21
 52c:	4f 91       	pop	r20
 52e:	3f 91       	pop	r19
 530:	2f 91       	pop	r18
 532:	0f 90       	pop	r0
 534:	0b be       	out	0x3b, r0	; 59
 536:	0f 90       	pop	r0
 538:	0f be       	out	0x3f, r0	; 63
 53a:	0f 90       	pop	r0
 53c:	1f 90       	pop	r1
 53e:	18 95       	reti

00000540 <_Z12serialEvent3v>:
#endif

#if defined(USART3_RX_vect) && defined(UDR3)
  void serialEvent3() __attribute__((weak));
  void serialEvent3() {}
 540:	08 95       	ret

00000542 <__vector_54>:
  #define serialEvent3_implemented
  ISR(USART3_RX_vect)
  {
 542:	1f 92       	push	r1
 544:	0f 92       	push	r0
 546:	0f b6       	in	r0, 0x3f	; 63
 548:	0f 92       	push	r0
 54a:	11 24       	eor	r1, r1
 54c:	0b b6       	in	r0, 0x3b	; 59
 54e:	0f 92       	push	r0
 550:	2f 93       	push	r18
 552:	3f 93       	push	r19
 554:	4f 93       	push	r20
 556:	5f 93       	push	r21
 558:	6f 93       	push	r22
 55a:	7f 93       	push	r23
 55c:	8f 93       	push	r24
 55e:	9f 93       	push	r25
 560:	af 93       	push	r26
 562:	bf 93       	push	r27
 564:	ef 93       	push	r30
 566:	ff 93       	push	r31
    if (bit_is_clear(UCSR3A, UPE3)) {
 568:	80 91 30 01 	lds	r24, 0x0130
 56c:	82 fd       	sbrc	r24, 2
 56e:	06 c0       	rjmp	.+12     	; 0x57c <__vector_54+0x3a>
      unsigned char c = UDR3;
 570:	80 91 36 01 	lds	r24, 0x0136
      store_char(c, &rx_buffer3);
 574:	6e ed       	ldi	r22, 0xDE	; 222
 576:	72 e0       	ldi	r23, 0x02	; 2
 578:	30 df       	rcall	.-416    	; 0x3da <_Z10store_charhP11ring_buffer>
 57a:	02 c0       	rjmp	.+4      	; 0x580 <__vector_54+0x3e>
 57c:	80 91 36 01 	lds	r24, 0x0136
    } else {
      unsigned char c = UDR3;
 580:	ff 91       	pop	r31
    };
  }
 582:	ef 91       	pop	r30
 584:	bf 91       	pop	r27
 586:	af 91       	pop	r26
 588:	9f 91       	pop	r25
 58a:	8f 91       	pop	r24
 58c:	7f 91       	pop	r23
 58e:	6f 91       	pop	r22
 590:	5f 91       	pop	r21
 592:	4f 91       	pop	r20
 594:	3f 91       	pop	r19
 596:	2f 91       	pop	r18
 598:	0f 90       	pop	r0
 59a:	0b be       	out	0x3b, r0	; 59
 59c:	0f 90       	pop	r0
 59e:	0f be       	out	0x3f, r0	; 63
 5a0:	0f 90       	pop	r0
 5a2:	1f 90       	pop	r1
 5a4:	18 95       	reti

000005a6 <_Z14serialEventRunv>:
#endif

void serialEventRun(void)
{
#ifdef serialEvent_implemented
  if (Serial.available()) serialEvent();
 5a6:	88 e7       	ldi	r24, 0x78	; 120
 5a8:	92 e0       	ldi	r25, 0x02	; 2
 5aa:	7e de       	rcall	.-772    	; 0x2a8 <_ZN14HardwareSerial9availableEv>
 5ac:	89 2b       	or	r24, r25
 5ae:	09 f0       	breq	.+2      	; 0x5b2 <_Z14serialEventRunv+0xc>
 5b0:	2e df       	rcall	.-420    	; 0x40e <_Z11serialEventv>
 5b2:	86 e5       	ldi	r24, 0x56	; 86
 5b4:	92 e0       	ldi	r25, 0x02	; 2
#endif
#ifdef serialEvent1_implemented
  if (Serial1.available()) serialEvent1();
 5b6:	78 de       	rcall	.-784    	; 0x2a8 <_ZN14HardwareSerial9availableEv>
 5b8:	89 2b       	or	r24, r25
 5ba:	09 f0       	breq	.+2      	; 0x5be <_Z14serialEventRunv+0x18>
 5bc:	5b df       	rcall	.-330    	; 0x474 <_Z12serialEvent1v>
 5be:	84 e3       	ldi	r24, 0x34	; 52
 5c0:	92 e0       	ldi	r25, 0x02	; 2
 5c2:	72 de       	rcall	.-796    	; 0x2a8 <_ZN14HardwareSerial9availableEv>
 5c4:	89 2b       	or	r24, r25
#endif
#ifdef serialEvent2_implemented
  if (Serial2.available()) serialEvent2();
 5c6:	09 f0       	breq	.+2      	; 0x5ca <_Z14serialEventRunv+0x24>
 5c8:	88 df       	rcall	.-240    	; 0x4da <_Z12serialEvent2v>
 5ca:	82 e1       	ldi	r24, 0x12	; 18
 5cc:	92 e0       	ldi	r25, 0x02	; 2
 5ce:	6c de       	rcall	.-808    	; 0x2a8 <_ZN14HardwareSerial9availableEv>
 5d0:	89 2b       	or	r24, r25
 5d2:	09 f0       	breq	.+2      	; 0x5d6 <_Z14serialEventRunv+0x30>
 5d4:	b5 cf       	rjmp	.-150    	; 0x540 <_Z12serialEvent3v>
#endif
#ifdef serialEvent3_implemented
  if (Serial3.available()) serialEvent3();
 5d6:	08 95       	ret

000005d8 <__vector_26>:
#elif defined(USART0_UDRE_vect)
ISR(USART0_UDRE_vect)
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#endif
{
 5d8:	1f 92       	push	r1
 5da:	0f 92       	push	r0
 5dc:	0f b6       	in	r0, 0x3f	; 63
 5de:	0f 92       	push	r0
 5e0:	11 24       	eor	r1, r1
 5e2:	0b b6       	in	r0, 0x3b	; 59
 5e4:	0f 92       	push	r0
 5e6:	2f 93       	push	r18
 5e8:	3f 93       	push	r19
 5ea:	8f 93       	push	r24
 5ec:	9f 93       	push	r25
 5ee:	ef 93       	push	r30
 5f0:	ff 93       	push	r31
  if (tx_buffer.head == tx_buffer.tail) {
 5f2:	20 91 72 04 	lds	r18, 0x0472
 5f6:	30 91 73 04 	lds	r19, 0x0473
 5fa:	80 91 74 04 	lds	r24, 0x0474
 5fe:	90 91 75 04 	lds	r25, 0x0475
 602:	28 17       	cp	r18, r24
 604:	39 07       	cpc	r19, r25
 606:	31 f4       	brne	.+12     	; 0x614 <__vector_26+0x3c>
	// Buffer empty, so disable interrupts
#if defined(UCSR0B)
    cbi(UCSR0B, UDRIE0);
 608:	80 91 c1 00 	lds	r24, 0x00C1
 60c:	8f 7d       	andi	r24, 0xDF	; 223
 60e:	80 93 c1 00 	sts	0x00C1, r24
 612:	14 c0       	rjmp	.+40     	; 0x63c <__vector_26+0x64>
    cbi(UCSRB, UDRIE);
#endif
  }
  else {
    // There is more data in the output buffer. Send the next byte
    unsigned char c = tx_buffer.buffer[tx_buffer.tail];
 614:	e0 91 74 04 	lds	r30, 0x0474
 618:	f0 91 75 04 	lds	r31, 0x0475
 61c:	ee 5c       	subi	r30, 0xCE	; 206
 61e:	fb 4f       	sbci	r31, 0xFB	; 251
 620:	20 81       	ld	r18, Z
    tx_buffer.tail = (tx_buffer.tail + 1) % SERIAL_BUFFER_SIZE;
 622:	80 91 74 04 	lds	r24, 0x0474
 626:	90 91 75 04 	lds	r25, 0x0475
 62a:	01 96       	adiw	r24, 0x01	; 1
 62c:	8f 73       	andi	r24, 0x3F	; 63
 62e:	99 27       	eor	r25, r25
 630:	90 93 75 04 	sts	0x0475, r25
 634:	80 93 74 04 	sts	0x0474, r24
	
  #if defined(UDR0)
    UDR0 = c;
 638:	20 93 c6 00 	sts	0x00C6, r18
    UDR = c;
  #else
    #error UDR not defined
  #endif
  }
}
 63c:	ff 91       	pop	r31
 63e:	ef 91       	pop	r30
 640:	9f 91       	pop	r25
 642:	8f 91       	pop	r24
 644:	3f 91       	pop	r19
 646:	2f 91       	pop	r18
 648:	0f 90       	pop	r0
 64a:	0b be       	out	0x3b, r0	; 59
 64c:	0f 90       	pop	r0
 64e:	0f be       	out	0x3f, r0	; 63
 650:	0f 90       	pop	r0
 652:	1f 90       	pop	r1
 654:	18 95       	reti

00000656 <__vector_37>:
#endif
#endif

#ifdef USART1_UDRE_vect
ISR(USART1_UDRE_vect)
{
 656:	1f 92       	push	r1
 658:	0f 92       	push	r0
 65a:	0f b6       	in	r0, 0x3f	; 63
 65c:	0f 92       	push	r0
 65e:	11 24       	eor	r1, r1
 660:	0b b6       	in	r0, 0x3b	; 59
 662:	0f 92       	push	r0
 664:	2f 93       	push	r18
 666:	3f 93       	push	r19
 668:	8f 93       	push	r24
 66a:	9f 93       	push	r25
 66c:	ef 93       	push	r30
 66e:	ff 93       	push	r31
  if (tx_buffer1.head == tx_buffer1.tail) {
 670:	20 91 ea 03 	lds	r18, 0x03EA
 674:	30 91 eb 03 	lds	r19, 0x03EB
 678:	80 91 ec 03 	lds	r24, 0x03EC
 67c:	90 91 ed 03 	lds	r25, 0x03ED
 680:	28 17       	cp	r18, r24
 682:	39 07       	cpc	r19, r25
 684:	31 f4       	brne	.+12     	; 0x692 <__vector_37+0x3c>
	// Buffer empty, so disable interrupts
    cbi(UCSR1B, UDRIE1);
 686:	80 91 c9 00 	lds	r24, 0x00C9
 68a:	8f 7d       	andi	r24, 0xDF	; 223
 68c:	80 93 c9 00 	sts	0x00C9, r24
 690:	14 c0       	rjmp	.+40     	; 0x6ba <__vector_37+0x64>
  }
  else {
    // There is more data in the output buffer. Send the next byte
    unsigned char c = tx_buffer1.buffer[tx_buffer1.tail];
 692:	e0 91 ec 03 	lds	r30, 0x03EC
 696:	f0 91 ed 03 	lds	r31, 0x03ED
 69a:	e6 55       	subi	r30, 0x56	; 86
 69c:	fc 4f       	sbci	r31, 0xFC	; 252
 69e:	20 81       	ld	r18, Z
    tx_buffer1.tail = (tx_buffer1.tail + 1) % SERIAL_BUFFER_SIZE;
 6a0:	80 91 ec 03 	lds	r24, 0x03EC
 6a4:	90 91 ed 03 	lds	r25, 0x03ED
 6a8:	01 96       	adiw	r24, 0x01	; 1
 6aa:	8f 73       	andi	r24, 0x3F	; 63
 6ac:	99 27       	eor	r25, r25
 6ae:	90 93 ed 03 	sts	0x03ED, r25
 6b2:	80 93 ec 03 	sts	0x03EC, r24
	
    UDR1 = c;
 6b6:	20 93 ce 00 	sts	0x00CE, r18
  }
}
 6ba:	ff 91       	pop	r31
 6bc:	ef 91       	pop	r30
 6be:	9f 91       	pop	r25
 6c0:	8f 91       	pop	r24
 6c2:	3f 91       	pop	r19
 6c4:	2f 91       	pop	r18
 6c6:	0f 90       	pop	r0
 6c8:	0b be       	out	0x3b, r0	; 59
 6ca:	0f 90       	pop	r0
 6cc:	0f be       	out	0x3f, r0	; 63
 6ce:	0f 90       	pop	r0
 6d0:	1f 90       	pop	r1
 6d2:	18 95       	reti

000006d4 <__vector_52>:
#endif

#ifdef USART2_UDRE_vect
ISR(USART2_UDRE_vect)
{
 6d4:	1f 92       	push	r1
 6d6:	0f 92       	push	r0
 6d8:	0f b6       	in	r0, 0x3f	; 63
 6da:	0f 92       	push	r0
 6dc:	11 24       	eor	r1, r1
 6de:	0b b6       	in	r0, 0x3b	; 59
 6e0:	0f 92       	push	r0
 6e2:	2f 93       	push	r18
 6e4:	3f 93       	push	r19
 6e6:	8f 93       	push	r24
 6e8:	9f 93       	push	r25
 6ea:	ef 93       	push	r30
 6ec:	ff 93       	push	r31
  if (tx_buffer2.head == tx_buffer2.tail) {
 6ee:	20 91 62 03 	lds	r18, 0x0362
 6f2:	30 91 63 03 	lds	r19, 0x0363
 6f6:	80 91 64 03 	lds	r24, 0x0364
 6fa:	90 91 65 03 	lds	r25, 0x0365
 6fe:	28 17       	cp	r18, r24
 700:	39 07       	cpc	r19, r25
 702:	31 f4       	brne	.+12     	; 0x710 <__vector_52+0x3c>
	// Buffer empty, so disable interrupts
    cbi(UCSR2B, UDRIE2);
 704:	80 91 d1 00 	lds	r24, 0x00D1
 708:	8f 7d       	andi	r24, 0xDF	; 223
 70a:	80 93 d1 00 	sts	0x00D1, r24
 70e:	14 c0       	rjmp	.+40     	; 0x738 <__vector_52+0x64>
  }
  else {
    // There is more data in the output buffer. Send the next byte
    unsigned char c = tx_buffer2.buffer[tx_buffer2.tail];
 710:	e0 91 64 03 	lds	r30, 0x0364
 714:	f0 91 65 03 	lds	r31, 0x0365
 718:	ee 5d       	subi	r30, 0xDE	; 222
 71a:	fc 4f       	sbci	r31, 0xFC	; 252
 71c:	20 81       	ld	r18, Z
    tx_buffer2.tail = (tx_buffer2.tail + 1) % SERIAL_BUFFER_SIZE;
 71e:	80 91 64 03 	lds	r24, 0x0364
 722:	90 91 65 03 	lds	r25, 0x0365
 726:	01 96       	adiw	r24, 0x01	; 1
 728:	8f 73       	andi	r24, 0x3F	; 63
 72a:	99 27       	eor	r25, r25
 72c:	90 93 65 03 	sts	0x0365, r25
 730:	80 93 64 03 	sts	0x0364, r24
	
    UDR2 = c;
 734:	20 93 d6 00 	sts	0x00D6, r18
  }
}
 738:	ff 91       	pop	r31
 73a:	ef 91       	pop	r30
 73c:	9f 91       	pop	r25
 73e:	8f 91       	pop	r24
 740:	3f 91       	pop	r19
 742:	2f 91       	pop	r18
 744:	0f 90       	pop	r0
 746:	0b be       	out	0x3b, r0	; 59
 748:	0f 90       	pop	r0
 74a:	0f be       	out	0x3f, r0	; 63
 74c:	0f 90       	pop	r0
 74e:	1f 90       	pop	r1
 750:	18 95       	reti

00000752 <__vector_55>:
#endif

#ifdef USART3_UDRE_vect
ISR(USART3_UDRE_vect)
{
 752:	1f 92       	push	r1
 754:	0f 92       	push	r0
 756:	0f b6       	in	r0, 0x3f	; 63
 758:	0f 92       	push	r0
 75a:	11 24       	eor	r1, r1
 75c:	0b b6       	in	r0, 0x3b	; 59
 75e:	0f 92       	push	r0
 760:	2f 93       	push	r18
 762:	3f 93       	push	r19
 764:	8f 93       	push	r24
 766:	9f 93       	push	r25
 768:	ef 93       	push	r30
 76a:	ff 93       	push	r31
  if (tx_buffer3.head == tx_buffer3.tail) {
 76c:	20 91 da 02 	lds	r18, 0x02DA
 770:	30 91 db 02 	lds	r19, 0x02DB
 774:	80 91 dc 02 	lds	r24, 0x02DC
 778:	90 91 dd 02 	lds	r25, 0x02DD
 77c:	28 17       	cp	r18, r24
 77e:	39 07       	cpc	r19, r25
 780:	31 f4       	brne	.+12     	; 0x78e <__vector_55+0x3c>
	// Buffer empty, so disable interrupts
    cbi(UCSR3B, UDRIE3);
 782:	80 91 31 01 	lds	r24, 0x0131
 786:	8f 7d       	andi	r24, 0xDF	; 223
 788:	80 93 31 01 	sts	0x0131, r24
 78c:	14 c0       	rjmp	.+40     	; 0x7b6 <__vector_55+0x64>
  }
  else {
    // There is more data in the output buffer. Send the next byte
    unsigned char c = tx_buffer3.buffer[tx_buffer3.tail];
 78e:	e0 91 dc 02 	lds	r30, 0x02DC
 792:	f0 91 dd 02 	lds	r31, 0x02DD
 796:	e6 56       	subi	r30, 0x66	; 102
 798:	fd 4f       	sbci	r31, 0xFD	; 253
 79a:	20 81       	ld	r18, Z
    tx_buffer3.tail = (tx_buffer3.tail + 1) % SERIAL_BUFFER_SIZE;
 79c:	80 91 dc 02 	lds	r24, 0x02DC
 7a0:	90 91 dd 02 	lds	r25, 0x02DD
 7a4:	01 96       	adiw	r24, 0x01	; 1
 7a6:	8f 73       	andi	r24, 0x3F	; 63
 7a8:	99 27       	eor	r25, r25
 7aa:	90 93 dd 02 	sts	0x02DD, r25
 7ae:	80 93 dc 02 	sts	0x02DC, r24
	
    UDR3 = c;
 7b2:	20 93 36 01 	sts	0x0136, r18
  }
}
 7b6:	ff 91       	pop	r31
 7b8:	ef 91       	pop	r30
 7ba:	9f 91       	pop	r25
 7bc:	8f 91       	pop	r24
 7be:	3f 91       	pop	r19
 7c0:	2f 91       	pop	r18
 7c2:	0f 90       	pop	r0
 7c4:	0b be       	out	0x3b, r0	; 59
 7c6:	0f 90       	pop	r0
 7c8:	0f be       	out	0x3f, r0	; 63
 7ca:	0f 90       	pop	r0
 7cc:	1f 90       	pop	r1
 7ce:	18 95       	reti

000007d0 <_ZN14HardwareSerial5beginEm>:
}

// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud)
{
 7d0:	cf 92       	push	r12
 7d2:	df 92       	push	r13
 7d4:	ef 92       	push	r14
 7d6:	ff 92       	push	r15
 7d8:	0f 93       	push	r16
 7da:	1f 93       	push	r17
 7dc:	cf 93       	push	r28
 7de:	df 93       	push	r29
 7e0:	ec 01       	movw	r28, r24
 7e2:	6a 01       	movw	r12, r20
 7e4:	7b 01       	movw	r14, r22
  }
#endif

try_again:
  
  if (use_u2x) {
 7e6:	41 15       	cp	r20, r1
 7e8:	51 4e       	sbci	r21, 0xE1	; 225
 7ea:	61 05       	cpc	r22, r1
 7ec:	71 05       	cpc	r23, r1
 7ee:	01 f1       	breq	.+64     	; 0x830 <_ZN14HardwareSerial5beginEm+0x60>
    *_ucsra = 1 << _u2x;
 7f0:	ec 89       	ldd	r30, Y+20	; 0x14
 7f2:	fd 89       	ldd	r31, Y+21	; 0x15
 7f4:	81 e0       	ldi	r24, 0x01	; 1
 7f6:	90 e0       	ldi	r25, 0x00	; 0
 7f8:	08 a0       	ldd	r0, Y+32	; 0x20
 7fa:	02 c0       	rjmp	.+4      	; 0x800 <_ZN14HardwareSerial5beginEm+0x30>
 7fc:	88 0f       	add	r24, r24
 7fe:	99 1f       	adc	r25, r25
 800:	0a 94       	dec	r0
 802:	e2 f7       	brpl	.-8      	; 0x7fc <_ZN14HardwareSerial5beginEm+0x2c>
 804:	80 83       	st	Z, r24
    baud_setting = (F_CPU / 4 / baud - 1) / 2;
 806:	60 e0       	ldi	r22, 0x00	; 0
 808:	79 e0       	ldi	r23, 0x09	; 9
 80a:	8d e3       	ldi	r24, 0x3D	; 61
 80c:	90 e0       	ldi	r25, 0x00	; 0
 80e:	a7 01       	movw	r20, r14
 810:	96 01       	movw	r18, r12
 812:	0a d2       	rcall	.+1044   	; 0xc28 <__udivmodsi4>
 814:	89 01       	movw	r16, r18
 816:	9a 01       	movw	r18, r20
 818:	01 50       	subi	r16, 0x01	; 1
 81a:	11 09       	sbc	r17, r1
 81c:	21 09       	sbc	r18, r1
 81e:	31 09       	sbc	r19, r1
 820:	36 95       	lsr	r19
 822:	27 95       	ror	r18
 824:	17 95       	ror	r17
 826:	07 95       	ror	r16
 828:	98 01       	movw	r18, r16
 82a:	01 15       	cp	r16, r1
  } else {
    *_ucsra = 0;
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
  }
  
  if ((baud_setting > 4095) && use_u2x)
 82c:	10 41       	sbci	r17, 0x10	; 16
 82e:	a0 f0       	brcs	.+40     	; 0x858 <_ZN14HardwareSerial5beginEm+0x88>
 830:	ec 89       	ldd	r30, Y+20	; 0x14
  
  if (use_u2x) {
    *_ucsra = 1 << _u2x;
    baud_setting = (F_CPU / 4 / baud - 1) / 2;
  } else {
    *_ucsra = 0;
 832:	fd 89       	ldd	r31, Y+21	; 0x15
 834:	10 82       	st	Z, r1
 836:	60 e8       	ldi	r22, 0x80	; 128
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
 838:	74 e8       	ldi	r23, 0x84	; 132
 83a:	8e e1       	ldi	r24, 0x1E	; 30
 83c:	90 e0       	ldi	r25, 0x00	; 0
 83e:	a7 01       	movw	r20, r14
 840:	96 01       	movw	r18, r12
 842:	f2 d1       	rcall	.+996    	; 0xc28 <__udivmodsi4>
 844:	da 01       	movw	r26, r20
 846:	c9 01       	movw	r24, r18
 848:	01 97       	sbiw	r24, 0x01	; 1
 84a:	a1 09       	sbc	r26, r1
 84c:	b1 09       	sbc	r27, r1
 84e:	b6 95       	lsr	r27
 850:	a7 95       	ror	r26
 852:	97 95       	ror	r25
 854:	87 95       	ror	r24
 856:	9c 01       	movw	r18, r24
 858:	e8 89       	ldd	r30, Y+16	; 0x10
 85a:	f9 89       	ldd	r31, Y+17	; 0x11
    use_u2x = false;
    goto try_again;
  }

  // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
 85c:	30 83       	st	Z, r19
 85e:	ea 89       	ldd	r30, Y+18	; 0x12
 860:	fb 89       	ldd	r31, Y+19	; 0x13
  *_ubrrl = baud_setting;
 862:	20 83       	st	Z, r18
 864:	19 a2       	std	Y+33, r1	; 0x21
 866:	ee 89       	ldd	r30, Y+22	; 0x16

  transmitting = false;
 868:	ff 89       	ldd	r31, Y+23	; 0x17

  sbi(*_ucsrb, _rxen);
 86a:	40 81       	ld	r20, Z
 86c:	81 e0       	ldi	r24, 0x01	; 1
 86e:	90 e0       	ldi	r25, 0x00	; 0
 870:	9c 01       	movw	r18, r24
 872:	0c 8c       	ldd	r0, Y+28	; 0x1c
 874:	02 c0       	rjmp	.+4      	; 0x87a <_ZN14HardwareSerial5beginEm+0xaa>
 876:	22 0f       	add	r18, r18
 878:	33 1f       	adc	r19, r19
 87a:	0a 94       	dec	r0
 87c:	e2 f7       	brpl	.-8      	; 0x876 <_ZN14HardwareSerial5beginEm+0xa6>
 87e:	24 2b       	or	r18, r20
 880:	20 83       	st	Z, r18
 882:	ee 89       	ldd	r30, Y+22	; 0x16
 884:	ff 89       	ldd	r31, Y+23	; 0x17
  sbi(*_ucsrb, _txen);
 886:	40 81       	ld	r20, Z
 888:	9c 01       	movw	r18, r24
 88a:	0d 8c       	ldd	r0, Y+29	; 0x1d
 88c:	02 c0       	rjmp	.+4      	; 0x892 <_ZN14HardwareSerial5beginEm+0xc2>
 88e:	22 0f       	add	r18, r18
 890:	33 1f       	adc	r19, r19
 892:	0a 94       	dec	r0
 894:	e2 f7       	brpl	.-8      	; 0x88e <_ZN14HardwareSerial5beginEm+0xbe>
 896:	24 2b       	or	r18, r20
 898:	20 83       	st	Z, r18
 89a:	ee 89       	ldd	r30, Y+22	; 0x16
 89c:	ff 89       	ldd	r31, Y+23	; 0x17
  sbi(*_ucsrb, _rxcie);
 89e:	40 81       	ld	r20, Z
 8a0:	9c 01       	movw	r18, r24
 8a2:	0e 8c       	ldd	r0, Y+30	; 0x1e
 8a4:	02 c0       	rjmp	.+4      	; 0x8aa <_ZN14HardwareSerial5beginEm+0xda>
 8a6:	22 0f       	add	r18, r18
 8a8:	33 1f       	adc	r19, r19
 8aa:	0a 94       	dec	r0
 8ac:	e2 f7       	brpl	.-8      	; 0x8a6 <_ZN14HardwareSerial5beginEm+0xd6>
 8ae:	24 2b       	or	r18, r20
 8b0:	20 83       	st	Z, r18
 8b2:	ee 89       	ldd	r30, Y+22	; 0x16
 8b4:	ff 89       	ldd	r31, Y+23	; 0x17
  cbi(*_ucsrb, _udrie);
 8b6:	20 81       	ld	r18, Z
 8b8:	0f 8c       	ldd	r0, Y+31	; 0x1f
 8ba:	02 c0       	rjmp	.+4      	; 0x8c0 <_ZN14HardwareSerial5beginEm+0xf0>
 8bc:	88 0f       	add	r24, r24
 8be:	99 1f       	adc	r25, r25
 8c0:	0a 94       	dec	r0
 8c2:	e2 f7       	brpl	.-8      	; 0x8bc <_ZN14HardwareSerial5beginEm+0xec>
 8c4:	80 95       	com	r24
 8c6:	82 23       	and	r24, r18
 8c8:	80 83       	st	Z, r24
 8ca:	df 91       	pop	r29
 8cc:	cf 91       	pop	r28
}
 8ce:	1f 91       	pop	r17
 8d0:	0f 91       	pop	r16
 8d2:	ff 90       	pop	r15
 8d4:	ef 90       	pop	r14
 8d6:	df 90       	pop	r13
 8d8:	cf 90       	pop	r12
 8da:	08 95       	ret

000008dc <_GLOBAL__sub_I_rx_buffer>:
#endif
#if defined(UBRR2H)
  HardwareSerial Serial2(&rx_buffer2, &tx_buffer2, &UBRR2H, &UBRR2L, &UCSR2A, &UCSR2B, &UCSR2C, &UDR2, RXEN2, TXEN2, RXCIE2, UDRIE2, U2X2);
#endif
#if defined(UBRR3H)
  HardwareSerial Serial3(&rx_buffer3, &tx_buffer3, &UBRR3H, &UBRR3L, &UCSR3A, &UCSR3B, &UCSR3C, &UDR3, RXEN3, TXEN3, RXCIE3, UDRIE3, U2X3);
 8dc:	cf 92       	push	r12
 8de:	df 92       	push	r13
 8e0:	ef 92       	push	r14
 8e2:	ff 92       	push	r15
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
 8e4:	e8 e7       	ldi	r30, 0x78	; 120
 8e6:	f2 e0       	ldi	r31, 0x02	; 2
 8e8:	13 82       	std	Z+3, r1	; 0x03
 8ea:	12 82       	std	Z+2, r1	; 0x02
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
 8ec:	88 ee       	ldi	r24, 0xE8	; 232
 8ee:	c8 2e       	mov	r12, r24
 8f0:	83 e0       	ldi	r24, 0x03	; 3
 8f2:	d8 2e       	mov	r13, r24
 8f4:	e1 2c       	mov	r14, r1
 8f6:	f1 2c       	mov	r15, r1
 8f8:	c4 82       	std	Z+4, r12	; 0x04
 8fa:	d5 82       	std	Z+5, r13	; 0x05
 8fc:	e6 82       	std	Z+6, r14	; 0x06
 8fe:	f7 82       	std	Z+7, r15	; 0x07

HardwareSerial::HardwareSerial(ring_buffer *rx_buffer, ring_buffer *tx_buffer,
  volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
  volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
  volatile uint8_t *ucsrc, volatile uint8_t *udr,
  uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udrie, uint8_t u2x)
 900:	66 e0       	ldi	r22, 0x06	; 6
 902:	72 e0       	ldi	r23, 0x02	; 2
 904:	71 83       	std	Z+1, r23	; 0x01
 906:	60 83       	st	Z, r22
{
  _rx_buffer = rx_buffer;
 908:	86 e7       	ldi	r24, 0x76	; 118
 90a:	94 e0       	ldi	r25, 0x04	; 4
 90c:	95 87       	std	Z+13, r25	; 0x0d
 90e:	84 87       	std	Z+12, r24	; 0x0c
  _tx_buffer = tx_buffer;
 910:	82 e3       	ldi	r24, 0x32	; 50
 912:	94 e0       	ldi	r25, 0x04	; 4
 914:	97 87       	std	Z+15, r25	; 0x0f
 916:	86 87       	std	Z+14, r24	; 0x0e
  _ubrrh = ubrrh;
 918:	85 ec       	ldi	r24, 0xC5	; 197
 91a:	90 e0       	ldi	r25, 0x00	; 0
 91c:	91 8b       	std	Z+17, r25	; 0x11
 91e:	80 8b       	std	Z+16, r24	; 0x10
  _ubrrl = ubrrl;
 920:	84 ec       	ldi	r24, 0xC4	; 196
 922:	90 e0       	ldi	r25, 0x00	; 0
 924:	93 8b       	std	Z+19, r25	; 0x13
 926:	82 8b       	std	Z+18, r24	; 0x12
  _ucsra = ucsra;
 928:	80 ec       	ldi	r24, 0xC0	; 192
 92a:	90 e0       	ldi	r25, 0x00	; 0
 92c:	95 8b       	std	Z+21, r25	; 0x15
 92e:	84 8b       	std	Z+20, r24	; 0x14
  _ucsrb = ucsrb;
 930:	81 ec       	ldi	r24, 0xC1	; 193
 932:	90 e0       	ldi	r25, 0x00	; 0
 934:	97 8b       	std	Z+23, r25	; 0x17
 936:	86 8b       	std	Z+22, r24	; 0x16
  _ucsrc = ucsrc;
 938:	82 ec       	ldi	r24, 0xC2	; 194
 93a:	90 e0       	ldi	r25, 0x00	; 0
 93c:	91 8f       	std	Z+25, r25	; 0x19
 93e:	80 8f       	std	Z+24, r24	; 0x18
  _udr = udr;
 940:	86 ec       	ldi	r24, 0xC6	; 198
 942:	90 e0       	ldi	r25, 0x00	; 0
 944:	93 8f       	std	Z+27, r25	; 0x1b
 946:	82 8f       	std	Z+26, r24	; 0x1a
  _rxen = rxen;
 948:	44 e0       	ldi	r20, 0x04	; 4
 94a:	44 8f       	std	Z+28, r20	; 0x1c
  _txen = txen;
 94c:	33 e0       	ldi	r19, 0x03	; 3
 94e:	35 8f       	std	Z+29, r19	; 0x1d
  _rxcie = rxcie;
 950:	27 e0       	ldi	r18, 0x07	; 7
 952:	26 8f       	std	Z+30, r18	; 0x1e
  _udrie = udrie;
 954:	95 e0       	ldi	r25, 0x05	; 5
 956:	97 8f       	std	Z+31, r25	; 0x1f
  _u2x = u2x;
 958:	81 e0       	ldi	r24, 0x01	; 1
 95a:	80 a3       	std	Z+32, r24	; 0x20
 95c:	e6 e5       	ldi	r30, 0x56	; 86
 95e:	f2 e0       	ldi	r31, 0x02	; 2
 960:	13 82       	std	Z+3, r1	; 0x03
 962:	12 82       	std	Z+2, r1	; 0x02
 964:	c4 82       	std	Z+4, r12	; 0x04
 966:	d5 82       	std	Z+5, r13	; 0x05
 968:	e6 82       	std	Z+6, r14	; 0x06
 96a:	f7 82       	std	Z+7, r15	; 0x07

HardwareSerial::HardwareSerial(ring_buffer *rx_buffer, ring_buffer *tx_buffer,
  volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
  volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
  volatile uint8_t *ucsrc, volatile uint8_t *udr,
  uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udrie, uint8_t u2x)
 96c:	71 83       	std	Z+1, r23	; 0x01
 96e:	60 83       	st	Z, r22
{
  _rx_buffer = rx_buffer;
 970:	ae ee       	ldi	r26, 0xEE	; 238
 972:	b3 e0       	ldi	r27, 0x03	; 3
 974:	b5 87       	std	Z+13, r27	; 0x0d
 976:	a4 87       	std	Z+12, r26	; 0x0c
  _tx_buffer = tx_buffer;
 978:	aa ea       	ldi	r26, 0xAA	; 170
 97a:	b3 e0       	ldi	r27, 0x03	; 3
 97c:	b7 87       	std	Z+15, r27	; 0x0f
 97e:	a6 87       	std	Z+14, r26	; 0x0e
  _ubrrh = ubrrh;
 980:	ad ec       	ldi	r26, 0xCD	; 205
 982:	b0 e0       	ldi	r27, 0x00	; 0
 984:	b1 8b       	std	Z+17, r27	; 0x11
 986:	a0 8b       	std	Z+16, r26	; 0x10
  _ubrrl = ubrrl;
 988:	ac ec       	ldi	r26, 0xCC	; 204
 98a:	b0 e0       	ldi	r27, 0x00	; 0
 98c:	b3 8b       	std	Z+19, r27	; 0x13
 98e:	a2 8b       	std	Z+18, r26	; 0x12
  _ucsra = ucsra;
 990:	a8 ec       	ldi	r26, 0xC8	; 200
 992:	b0 e0       	ldi	r27, 0x00	; 0
 994:	b5 8b       	std	Z+21, r27	; 0x15
 996:	a4 8b       	std	Z+20, r26	; 0x14
  _ucsrb = ucsrb;
 998:	a9 ec       	ldi	r26, 0xC9	; 201
 99a:	b0 e0       	ldi	r27, 0x00	; 0
 99c:	b7 8b       	std	Z+23, r27	; 0x17
 99e:	a6 8b       	std	Z+22, r26	; 0x16
  _ucsrc = ucsrc;
 9a0:	aa ec       	ldi	r26, 0xCA	; 202
 9a2:	b0 e0       	ldi	r27, 0x00	; 0
 9a4:	b1 8f       	std	Z+25, r27	; 0x19
 9a6:	a0 8f       	std	Z+24, r26	; 0x18
  _udr = udr;
 9a8:	ae ec       	ldi	r26, 0xCE	; 206
 9aa:	b0 e0       	ldi	r27, 0x00	; 0
 9ac:	b3 8f       	std	Z+27, r27	; 0x1b
 9ae:	a2 8f       	std	Z+26, r26	; 0x1a
  _rxen = rxen;
 9b0:	44 8f       	std	Z+28, r20	; 0x1c
  _txen = txen;
 9b2:	35 8f       	std	Z+29, r19	; 0x1d
  _rxcie = rxcie;
 9b4:	26 8f       	std	Z+30, r18	; 0x1e
  _udrie = udrie;
 9b6:	97 8f       	std	Z+31, r25	; 0x1f
  _u2x = u2x;
 9b8:	80 a3       	std	Z+32, r24	; 0x20
 9ba:	e4 e3       	ldi	r30, 0x34	; 52
 9bc:	f2 e0       	ldi	r31, 0x02	; 2
 9be:	13 82       	std	Z+3, r1	; 0x03
 9c0:	12 82       	std	Z+2, r1	; 0x02
 9c2:	c4 82       	std	Z+4, r12	; 0x04
 9c4:	d5 82       	std	Z+5, r13	; 0x05
 9c6:	e6 82       	std	Z+6, r14	; 0x06
 9c8:	f7 82       	std	Z+7, r15	; 0x07

HardwareSerial::HardwareSerial(ring_buffer *rx_buffer, ring_buffer *tx_buffer,
  volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
  volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
  volatile uint8_t *ucsrc, volatile uint8_t *udr,
  uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udrie, uint8_t u2x)
 9ca:	71 83       	std	Z+1, r23	; 0x01
 9cc:	60 83       	st	Z, r22
{
  _rx_buffer = rx_buffer;
 9ce:	a6 e6       	ldi	r26, 0x66	; 102
 9d0:	b3 e0       	ldi	r27, 0x03	; 3
 9d2:	b5 87       	std	Z+13, r27	; 0x0d
 9d4:	a4 87       	std	Z+12, r26	; 0x0c
  _tx_buffer = tx_buffer;
 9d6:	a2 e2       	ldi	r26, 0x22	; 34
 9d8:	b3 e0       	ldi	r27, 0x03	; 3
 9da:	b7 87       	std	Z+15, r27	; 0x0f
 9dc:	a6 87       	std	Z+14, r26	; 0x0e
  _ubrrh = ubrrh;
 9de:	a5 ed       	ldi	r26, 0xD5	; 213
 9e0:	b0 e0       	ldi	r27, 0x00	; 0
 9e2:	b1 8b       	std	Z+17, r27	; 0x11
 9e4:	a0 8b       	std	Z+16, r26	; 0x10
  _ubrrl = ubrrl;
 9e6:	a4 ed       	ldi	r26, 0xD4	; 212
 9e8:	b0 e0       	ldi	r27, 0x00	; 0
 9ea:	b3 8b       	std	Z+19, r27	; 0x13
 9ec:	a2 8b       	std	Z+18, r26	; 0x12
  _ucsra = ucsra;
 9ee:	a0 ed       	ldi	r26, 0xD0	; 208
 9f0:	b0 e0       	ldi	r27, 0x00	; 0
 9f2:	b5 8b       	std	Z+21, r27	; 0x15
 9f4:	a4 8b       	std	Z+20, r26	; 0x14
  _ucsrb = ucsrb;
 9f6:	a1 ed       	ldi	r26, 0xD1	; 209
 9f8:	b0 e0       	ldi	r27, 0x00	; 0
 9fa:	b7 8b       	std	Z+23, r27	; 0x17
 9fc:	a6 8b       	std	Z+22, r26	; 0x16
  _ucsrc = ucsrc;
 9fe:	a2 ed       	ldi	r26, 0xD2	; 210
 a00:	b0 e0       	ldi	r27, 0x00	; 0
 a02:	b1 8f       	std	Z+25, r27	; 0x19
 a04:	a0 8f       	std	Z+24, r26	; 0x18
  _udr = udr;
 a06:	a6 ed       	ldi	r26, 0xD6	; 214
 a08:	b0 e0       	ldi	r27, 0x00	; 0
 a0a:	b3 8f       	std	Z+27, r27	; 0x1b
 a0c:	a2 8f       	std	Z+26, r26	; 0x1a
  _rxen = rxen;
 a0e:	44 8f       	std	Z+28, r20	; 0x1c
  _txen = txen;
 a10:	35 8f       	std	Z+29, r19	; 0x1d
  _rxcie = rxcie;
 a12:	26 8f       	std	Z+30, r18	; 0x1e
  _udrie = udrie;
 a14:	97 8f       	std	Z+31, r25	; 0x1f
  _u2x = u2x;
 a16:	80 a3       	std	Z+32, r24	; 0x20
 a18:	e2 e1       	ldi	r30, 0x12	; 18
 a1a:	f2 e0       	ldi	r31, 0x02	; 2
 a1c:	13 82       	std	Z+3, r1	; 0x03
 a1e:	12 82       	std	Z+2, r1	; 0x02
 a20:	c4 82       	std	Z+4, r12	; 0x04
 a22:	d5 82       	std	Z+5, r13	; 0x05
 a24:	e6 82       	std	Z+6, r14	; 0x06
 a26:	f7 82       	std	Z+7, r15	; 0x07

HardwareSerial::HardwareSerial(ring_buffer *rx_buffer, ring_buffer *tx_buffer,
  volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
  volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
  volatile uint8_t *ucsrc, volatile uint8_t *udr,
  uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udrie, uint8_t u2x)
 a28:	71 83       	std	Z+1, r23	; 0x01
 a2a:	60 83       	st	Z, r22
{
  _rx_buffer = rx_buffer;
 a2c:	6e ed       	ldi	r22, 0xDE	; 222
 a2e:	72 e0       	ldi	r23, 0x02	; 2
 a30:	75 87       	std	Z+13, r23	; 0x0d
 a32:	64 87       	std	Z+12, r22	; 0x0c
  _tx_buffer = tx_buffer;
 a34:	6a e9       	ldi	r22, 0x9A	; 154
 a36:	72 e0       	ldi	r23, 0x02	; 2
 a38:	77 87       	std	Z+15, r23	; 0x0f
 a3a:	66 87       	std	Z+14, r22	; 0x0e
  _ubrrh = ubrrh;
 a3c:	65 e3       	ldi	r22, 0x35	; 53
 a3e:	71 e0       	ldi	r23, 0x01	; 1
 a40:	71 8b       	std	Z+17, r23	; 0x11
 a42:	60 8b       	std	Z+16, r22	; 0x10
  _ubrrl = ubrrl;
 a44:	64 e3       	ldi	r22, 0x34	; 52
 a46:	71 e0       	ldi	r23, 0x01	; 1
 a48:	73 8b       	std	Z+19, r23	; 0x13
 a4a:	62 8b       	std	Z+18, r22	; 0x12
  _ucsra = ucsra;
 a4c:	60 e3       	ldi	r22, 0x30	; 48
 a4e:	71 e0       	ldi	r23, 0x01	; 1
 a50:	75 8b       	std	Z+21, r23	; 0x15
 a52:	64 8b       	std	Z+20, r22	; 0x14
  _ucsrb = ucsrb;
 a54:	61 e3       	ldi	r22, 0x31	; 49
 a56:	71 e0       	ldi	r23, 0x01	; 1
 a58:	77 8b       	std	Z+23, r23	; 0x17
 a5a:	66 8b       	std	Z+22, r22	; 0x16
  _ucsrc = ucsrc;
 a5c:	62 e3       	ldi	r22, 0x32	; 50
 a5e:	71 e0       	ldi	r23, 0x01	; 1
 a60:	71 8f       	std	Z+25, r23	; 0x19
 a62:	60 8f       	std	Z+24, r22	; 0x18
  _udr = udr;
 a64:	66 e3       	ldi	r22, 0x36	; 54
 a66:	71 e0       	ldi	r23, 0x01	; 1
 a68:	73 8f       	std	Z+27, r23	; 0x1b
 a6a:	62 8f       	std	Z+26, r22	; 0x1a
  _rxen = rxen;
 a6c:	44 8f       	std	Z+28, r20	; 0x1c
  _txen = txen;
 a6e:	35 8f       	std	Z+29, r19	; 0x1d
  _rxcie = rxcie;
 a70:	26 8f       	std	Z+30, r18	; 0x1e
  _udrie = udrie;
 a72:	97 8f       	std	Z+31, r25	; 0x1f
  _u2x = u2x;
 a74:	80 a3       	std	Z+32, r24	; 0x20
#endif
#if defined(UBRR2H)
  HardwareSerial Serial2(&rx_buffer2, &tx_buffer2, &UBRR2H, &UBRR2L, &UCSR2A, &UCSR2B, &UCSR2C, &UDR2, RXEN2, TXEN2, RXCIE2, UDRIE2, U2X2);
#endif
#if defined(UBRR3H)
  HardwareSerial Serial3(&rx_buffer3, &tx_buffer3, &UBRR3H, &UBRR3L, &UCSR3A, &UCSR3B, &UCSR3C, &UDR3, RXEN3, TXEN3, RXCIE3, UDRIE3, U2X3);
 a76:	ff 90       	pop	r15
 a78:	ef 90       	pop	r14
 a7a:	df 90       	pop	r13
 a7c:	cf 90       	pop	r12
 a7e:	08 95       	ret

00000a80 <__vector_23>:
#if defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
 a80:	1f 92       	push	r1
 a82:	0f 92       	push	r0
 a84:	0f b6       	in	r0, 0x3f	; 63
 a86:	0f 92       	push	r0
 a88:	11 24       	eor	r1, r1
 a8a:	2f 93       	push	r18
 a8c:	3f 93       	push	r19
 a8e:	8f 93       	push	r24
 a90:	9f 93       	push	r25
 a92:	af 93       	push	r26
 a94:	bf 93       	push	r27
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
 a96:	80 91 bb 04 	lds	r24, 0x04BB
 a9a:	90 91 bc 04 	lds	r25, 0x04BC
 a9e:	a0 91 bd 04 	lds	r26, 0x04BD
 aa2:	b0 91 be 04 	lds	r27, 0x04BE
	unsigned char f = timer0_fract;
 aa6:	30 91 ba 04 	lds	r19, 0x04BA

	m += MILLIS_INC;
	f += FRACT_INC;
 aaa:	23 e0       	ldi	r18, 0x03	; 3
 aac:	23 0f       	add	r18, r19
	if (f >= FRACT_MAX) {
 aae:	2d 37       	cpi	r18, 0x7D	; 125
 ab0:	20 f4       	brcc	.+8      	; 0xaba <__vector_23+0x3a>
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
 ab2:	01 96       	adiw	r24, 0x01	; 1
 ab4:	a1 1d       	adc	r26, r1
 ab6:	b1 1d       	adc	r27, r1
 ab8:	05 c0       	rjmp	.+10     	; 0xac4 <__vector_23+0x44>
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
 aba:	26 e8       	ldi	r18, 0x86	; 134
 abc:	23 0f       	add	r18, r19
		m += 1;
 abe:	02 96       	adiw	r24, 0x02	; 2
 ac0:	a1 1d       	adc	r26, r1
 ac2:	b1 1d       	adc	r27, r1
	}

	timer0_fract = f;
 ac4:	20 93 ba 04 	sts	0x04BA, r18
	timer0_millis = m;
 ac8:	80 93 bb 04 	sts	0x04BB, r24
 acc:	90 93 bc 04 	sts	0x04BC, r25
 ad0:	a0 93 bd 04 	sts	0x04BD, r26
 ad4:	b0 93 be 04 	sts	0x04BE, r27
	timer0_overflow_count++;
 ad8:	80 91 bf 04 	lds	r24, 0x04BF
 adc:	90 91 c0 04 	lds	r25, 0x04C0
 ae0:	a0 91 c1 04 	lds	r26, 0x04C1
 ae4:	b0 91 c2 04 	lds	r27, 0x04C2
 ae8:	01 96       	adiw	r24, 0x01	; 1
 aea:	a1 1d       	adc	r26, r1
 aec:	b1 1d       	adc	r27, r1
 aee:	80 93 bf 04 	sts	0x04BF, r24
 af2:	90 93 c0 04 	sts	0x04C0, r25
 af6:	a0 93 c1 04 	sts	0x04C1, r26
 afa:	b0 93 c2 04 	sts	0x04C2, r27
}
 afe:	bf 91       	pop	r27
 b00:	af 91       	pop	r26
 b02:	9f 91       	pop	r25
 b04:	8f 91       	pop	r24
 b06:	3f 91       	pop	r19
 b08:	2f 91       	pop	r18
 b0a:	0f 90       	pop	r0
 b0c:	0f be       	out	0x3f, r0	; 63
 b0e:	0f 90       	pop	r0
 b10:	1f 90       	pop	r1
 b12:	18 95       	reti

00000b14 <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 b14:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 b16:	84 b5       	in	r24, 0x24	; 36
 b18:	82 60       	ori	r24, 0x02	; 2
 b1a:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
 b1c:	84 b5       	in	r24, 0x24	; 36
 b1e:	81 60       	ori	r24, 0x01	; 1
 b20:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 b22:	85 b5       	in	r24, 0x25	; 37
 b24:	82 60       	ori	r24, 0x02	; 2
 b26:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
 b28:	85 b5       	in	r24, 0x25	; 37
 b2a:	81 60       	ori	r24, 0x01	; 1
 b2c:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 b2e:	ee e6       	ldi	r30, 0x6E	; 110
 b30:	f0 e0       	ldi	r31, 0x00	; 0
 b32:	80 81       	ld	r24, Z
 b34:	81 60       	ori	r24, 0x01	; 1
 b36:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 b38:	e1 e8       	ldi	r30, 0x81	; 129
 b3a:	f0 e0       	ldi	r31, 0x00	; 0
 b3c:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 b3e:	80 81       	ld	r24, Z
 b40:	82 60       	ori	r24, 0x02	; 2
 b42:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 b44:	80 81       	ld	r24, Z
 b46:	81 60       	ori	r24, 0x01	; 1
 b48:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 b4a:	e0 e8       	ldi	r30, 0x80	; 128
 b4c:	f0 e0       	ldi	r31, 0x00	; 0
 b4e:	80 81       	ld	r24, Z
 b50:	81 60       	ori	r24, 0x01	; 1
 b52:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 b54:	e1 eb       	ldi	r30, 0xB1	; 177
 b56:	f0 e0       	ldi	r31, 0x00	; 0
 b58:	80 81       	ld	r24, Z
 b5a:	84 60       	ori	r24, 0x04	; 4
 b5c:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 b5e:	e0 eb       	ldi	r30, 0xB0	; 176
 b60:	f0 e0       	ldi	r31, 0x00	; 0
 b62:	80 81       	ld	r24, Z
 b64:	81 60       	ori	r24, 0x01	; 1
 b66:	80 83       	st	Z, r24
#else
	#warning Timer 2 not finished (may not be present on this CPU)
#endif

#if defined(TCCR3B) && defined(CS31) && defined(WGM30)
	sbi(TCCR3B, CS31);		// set timer 3 prescale factor to 64
 b68:	e1 e9       	ldi	r30, 0x91	; 145
 b6a:	f0 e0       	ldi	r31, 0x00	; 0
 b6c:	80 81       	ld	r24, Z
 b6e:	82 60       	ori	r24, 0x02	; 2
 b70:	80 83       	st	Z, r24
	sbi(TCCR3B, CS30);
 b72:	80 81       	ld	r24, Z
 b74:	81 60       	ori	r24, 0x01	; 1
 b76:	80 83       	st	Z, r24
	sbi(TCCR3A, WGM30);		// put timer 3 in 8-bit phase correct pwm mode
 b78:	e0 e9       	ldi	r30, 0x90	; 144
 b7a:	f0 e0       	ldi	r31, 0x00	; 0
 b7c:	80 81       	ld	r24, Z
 b7e:	81 60       	ori	r24, 0x01	; 1
 b80:	80 83       	st	Z, r24
	sbi(TCCR4D, WGM40);		// put timer 4 in phase- and frequency-correct PWM mode	
	sbi(TCCR4A, PWM4A);		// enable PWM mode for comparator OCR4A
	sbi(TCCR4C, PWM4D);		// enable PWM mode for comparator OCR4D
#else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */
#if defined(TCCR4B) && defined(CS41) && defined(WGM40)
	sbi(TCCR4B, CS41);		// set timer 4 prescale factor to 64
 b82:	e1 ea       	ldi	r30, 0xA1	; 161
 b84:	f0 e0       	ldi	r31, 0x00	; 0
 b86:	80 81       	ld	r24, Z
 b88:	82 60       	ori	r24, 0x02	; 2
 b8a:	80 83       	st	Z, r24
	sbi(TCCR4B, CS40);
 b8c:	80 81       	ld	r24, Z
 b8e:	81 60       	ori	r24, 0x01	; 1
 b90:	80 83       	st	Z, r24
	sbi(TCCR4A, WGM40);		// put timer 4 in 8-bit phase correct pwm mode
 b92:	e0 ea       	ldi	r30, 0xA0	; 160
 b94:	f0 e0       	ldi	r31, 0x00	; 0
 b96:	80 81       	ld	r24, Z
 b98:	81 60       	ori	r24, 0x01	; 1
 b9a:	80 83       	st	Z, r24
#endif
#endif /* end timer4 block for ATMEGA1280/2560 and similar */	

#if defined(TCCR5B) && defined(CS51) && defined(WGM50)
	sbi(TCCR5B, CS51);		// set timer 5 prescale factor to 64
 b9c:	e1 e2       	ldi	r30, 0x21	; 33
 b9e:	f1 e0       	ldi	r31, 0x01	; 1
 ba0:	80 81       	ld	r24, Z
 ba2:	82 60       	ori	r24, 0x02	; 2
 ba4:	80 83       	st	Z, r24
	sbi(TCCR5B, CS50);
 ba6:	80 81       	ld	r24, Z
 ba8:	81 60       	ori	r24, 0x01	; 1
 baa:	80 83       	st	Z, r24
	sbi(TCCR5A, WGM50);		// put timer 5 in 8-bit phase correct pwm mode
 bac:	e0 e2       	ldi	r30, 0x20	; 32
 bae:	f1 e0       	ldi	r31, 0x01	; 1
 bb0:	80 81       	ld	r24, Z
 bb2:	81 60       	ori	r24, 0x01	; 1
 bb4:	80 83       	st	Z, r24
#if defined(ADCSRA)
	// set a2d prescale factor to 128
	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.
	// XXX: this will not work properly for other clock speeds, and
	// this code should use F_CPU to determine the prescale factor.
	sbi(ADCSRA, ADPS2);
 bb6:	ea e7       	ldi	r30, 0x7A	; 122
 bb8:	f0 e0       	ldi	r31, 0x00	; 0
 bba:	80 81       	ld	r24, Z
 bbc:	84 60       	ori	r24, 0x04	; 4
 bbe:	80 83       	st	Z, r24
	sbi(ADCSRA, ADPS1);
 bc0:	80 81       	ld	r24, Z
 bc2:	82 60       	ori	r24, 0x02	; 2
 bc4:	80 83       	st	Z, r24
	sbi(ADCSRA, ADPS0);
 bc6:	80 81       	ld	r24, Z
 bc8:	81 60       	ori	r24, 0x01	; 1
 bca:	80 83       	st	Z, r24

	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 bcc:	80 81       	ld	r24, Z
 bce:	80 68       	ori	r24, 0x80	; 128
 bd0:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
 bd2:	10 92 c1 00 	sts	0x00C1, r1
 bd6:	08 95       	ret

00000bd8 <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 bd8:	cf 92       	push	r12
 bda:	df 92       	push	r13
 bdc:	ef 92       	push	r14
 bde:	ff 92       	push	r15
 be0:	0f 93       	push	r16
 be2:	1f 93       	push	r17
 be4:	cf 93       	push	r28
 be6:	df 93       	push	r29
 be8:	6c 01       	movw	r12, r24
 bea:	eb 01       	movw	r28, r22
 bec:	7b 01       	movw	r14, r22
 bee:	e4 0e       	add	r14, r20
 bf0:	f5 1e       	adc	r15, r21
  size_t n = 0;
 bf2:	00 e0       	ldi	r16, 0x00	; 0
 bf4:	10 e0       	ldi	r17, 0x00	; 0
  while (size--) {
 bf6:	ce 15       	cp	r28, r14
 bf8:	df 05       	cpc	r29, r15
 bfa:	61 f0       	breq	.+24     	; 0xc14 <_ZN5Print5writeEPKhj+0x3c>
    n += write(*buffer++);
 bfc:	69 91       	ld	r22, Y+
 bfe:	d6 01       	movw	r26, r12
 c00:	ed 91       	ld	r30, X+
 c02:	fc 91       	ld	r31, X
 c04:	01 90       	ld	r0, Z+
 c06:	f0 81       	ld	r31, Z
 c08:	e0 2d       	mov	r30, r0
 c0a:	c6 01       	movw	r24, r12
 c0c:	19 95       	eicall
 c0e:	08 0f       	add	r16, r24
 c10:	19 1f       	adc	r17, r25
 c12:	f1 cf       	rjmp	.-30     	; 0xbf6 <_ZN5Print5writeEPKhj+0x1e>
  }
  return n;
}
 c14:	c8 01       	movw	r24, r16
 c16:	df 91       	pop	r29
 c18:	cf 91       	pop	r28
 c1a:	1f 91       	pop	r17
 c1c:	0f 91       	pop	r16
 c1e:	ff 90       	pop	r15
 c20:	ef 90       	pop	r14
 c22:	df 90       	pop	r13
 c24:	cf 90       	pop	r12
 c26:	08 95       	ret

00000c28 <__udivmodsi4>:
 c28:	a1 e2       	ldi	r26, 0x21	; 33
 c2a:	1a 2e       	mov	r1, r26
 c2c:	aa 1b       	sub	r26, r26
 c2e:	bb 1b       	sub	r27, r27
 c30:	fd 01       	movw	r30, r26
 c32:	0d c0       	rjmp	.+26     	; 0xc4e <__udivmodsi4_ep>

00000c34 <__udivmodsi4_loop>:
 c34:	aa 1f       	adc	r26, r26
 c36:	bb 1f       	adc	r27, r27
 c38:	ee 1f       	adc	r30, r30
 c3a:	ff 1f       	adc	r31, r31
 c3c:	a2 17       	cp	r26, r18
 c3e:	b3 07       	cpc	r27, r19
 c40:	e4 07       	cpc	r30, r20
 c42:	f5 07       	cpc	r31, r21
 c44:	20 f0       	brcs	.+8      	; 0xc4e <__udivmodsi4_ep>
 c46:	a2 1b       	sub	r26, r18
 c48:	b3 0b       	sbc	r27, r19
 c4a:	e4 0b       	sbc	r30, r20
 c4c:	f5 0b       	sbc	r31, r21

00000c4e <__udivmodsi4_ep>:
 c4e:	66 1f       	adc	r22, r22
 c50:	77 1f       	adc	r23, r23
 c52:	88 1f       	adc	r24, r24
 c54:	99 1f       	adc	r25, r25
 c56:	1a 94       	dec	r1
 c58:	69 f7       	brne	.-38     	; 0xc34 <__udivmodsi4_loop>
 c5a:	60 95       	com	r22
 c5c:	70 95       	com	r23
 c5e:	80 95       	com	r24
 c60:	90 95       	com	r25
 c62:	9b 01       	movw	r18, r22
 c64:	ac 01       	movw	r20, r24
 c66:	bd 01       	movw	r22, r26
 c68:	cf 01       	movw	r24, r30
 c6a:	08 95       	ret

00000c6c <__tablejump2__>:
 c6c:	ee 0f       	add	r30, r30
 c6e:	ff 1f       	adc	r31, r31
 c70:	88 1f       	adc	r24, r24
 c72:	8b bf       	out	0x3b, r24	; 59
 c74:	07 90       	elpm	r0, Z+
 c76:	f6 91       	elpm	r31, Z
 c78:	e0 2d       	mov	r30, r0
 c7a:	19 94       	eijmp

00000c7c <_exit>:
 c7c:	f8 94       	cli

00000c7e <__stop_program>:
 c7e:	ff cf       	rjmp	.-2      	; 0xc7e <__stop_program>
